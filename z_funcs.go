// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package lua

import (
	"reflect"

	lua "github.com/yuin/gopher-lua"
)

func init() {
	typ := reflect.TypeOf((*func(String) (String, error))(nil)).Elem()
	builtin[typ] = makeFuncStringString
}

// makeFuncStringString generates a function that accepts a String and outputs a String
func makeFuncStringString(v interface{}) lua.LGFunction {
	f := v.(func(String) (String, error))
	return func(state *lua.LState) int {
		v, err := f(String(state.CheckString(1)))
		if err != nil {
			state.RaiseError(err.Error())
			return 0
		}

		state.Push(luaValueOf(v))
		return 1
	}
}

func init() {
	typ := reflect.TypeOf((*func(String) (Number, error))(nil)).Elem()
	builtin[typ] = makeFuncStringNumber
}

// makeFuncStringNumber generates a function that accepts a String and outputs a Number
func makeFuncStringNumber(v interface{}) lua.LGFunction {
	f := v.(func(String) (Number, error))
	return func(state *lua.LState) int {
		v, err := f(String(state.CheckString(1)))
		if err != nil {
			state.RaiseError(err.Error())
			return 0
		}

		state.Push(luaValueOf(v))
		return 1
	}
}

func init() {
	typ := reflect.TypeOf((*func(String) (Bool, error))(nil)).Elem()
	builtin[typ] = makeFuncStringBool
}

// makeFuncStringBool generates a function that accepts a String and outputs a Bool
func makeFuncStringBool(v interface{}) lua.LGFunction {
	f := v.(func(String) (Bool, error))
	return func(state *lua.LState) int {
		v, err := f(String(state.CheckString(1)))
		if err != nil {
			state.RaiseError(err.Error())
			return 0
		}

		state.Push(luaValueOf(v))
		return 1
	}
}

func init() {
	typ := reflect.TypeOf((*func(Number) (String, error))(nil)).Elem()
	builtin[typ] = makeFuncNumberString
}

// makeFuncNumberString generates a function that accepts a Number and outputs a String
func makeFuncNumberString(v interface{}) lua.LGFunction {
	f := v.(func(Number) (String, error))
	return func(state *lua.LState) int {
		v, err := f(Number(state.CheckNumber(1)))
		if err != nil {
			state.RaiseError(err.Error())
			return 0
		}

		state.Push(luaValueOf(v))
		return 1
	}
}

func init() {
	typ := reflect.TypeOf((*func(Number) (Number, error))(nil)).Elem()
	builtin[typ] = makeFuncNumberNumber
}

// makeFuncNumberNumber generates a function that accepts a Number and outputs a Number
func makeFuncNumberNumber(v interface{}) lua.LGFunction {
	f := v.(func(Number) (Number, error))
	return func(state *lua.LState) int {
		v, err := f(Number(state.CheckNumber(1)))
		if err != nil {
			state.RaiseError(err.Error())
			return 0
		}

		state.Push(luaValueOf(v))
		return 1
	}
}

func init() {
	typ := reflect.TypeOf((*func(Number) (Bool, error))(nil)).Elem()
	builtin[typ] = makeFuncNumberBool
}

// makeFuncNumberBool generates a function that accepts a Number and outputs a Bool
func makeFuncNumberBool(v interface{}) lua.LGFunction {
	f := v.(func(Number) (Bool, error))
	return func(state *lua.LState) int {
		v, err := f(Number(state.CheckNumber(1)))
		if err != nil {
			state.RaiseError(err.Error())
			return 0
		}

		state.Push(luaValueOf(v))
		return 1
	}
}

func init() {
	typ := reflect.TypeOf((*func(Bool) (String, error))(nil)).Elem()
	builtin[typ] = makeFuncBoolString
}

// makeFuncBoolString generates a function that accepts a Bool and outputs a String
func makeFuncBoolString(v interface{}) lua.LGFunction {
	f := v.(func(Bool) (String, error))
	return func(state *lua.LState) int {
		v, err := f(Bool(state.CheckBool(1)))
		if err != nil {
			state.RaiseError(err.Error())
			return 0
		}

		state.Push(luaValueOf(v))
		return 1
	}
}

func init() {
	typ := reflect.TypeOf((*func(Bool) (Number, error))(nil)).Elem()
	builtin[typ] = makeFuncBoolNumber
}

// makeFuncBoolNumber generates a function that accepts a Bool and outputs a Number
func makeFuncBoolNumber(v interface{}) lua.LGFunction {
	f := v.(func(Bool) (Number, error))
	return func(state *lua.LState) int {
		v, err := f(Bool(state.CheckBool(1)))
		if err != nil {
			state.RaiseError(err.Error())
			return 0
		}

		state.Push(luaValueOf(v))
		return 1
	}
}

func init() {
	typ := reflect.TypeOf((*func(Bool) (Bool, error))(nil)).Elem()
	builtin[typ] = makeFuncBoolBool
}

// makeFuncBoolBool generates a function that accepts a Bool and outputs a Bool
func makeFuncBoolBool(v interface{}) lua.LGFunction {
	f := v.(func(Bool) (Bool, error))
	return func(state *lua.LState) int {
		v, err := f(Bool(state.CheckBool(1)))
		if err != nil {
			state.RaiseError(err.Error())
			return 0
		}

		state.Push(luaValueOf(v))
		return 1
	}
}
